# Back-End and Feature Testing

#### Outside-In Test-Driven Development

- Outside-in TDD takes the red, green, refactor logic from TDD and provides a framework for how to build a full-stack application. As it sounds, you will start from the outside, the UI or view layer, and then work your way deeper into the application until you reach the database layer as you TDD.
- If a test pushes you to a lower level, restart you red, green refactor by writing a new test.
- Once tests are written, it can be a good idea to delete some tests that are unneeded. Since you're testing at different layers, it is likely that your tests are covering the same functionality. You want to remove tests that will save the test suite on time to run, while not decreasing your confidence in the functionality of the code.

#### Introduction to Headless Browser Testing

Headless browser testing is a way to run UI tests without the UI or the "head". This is useful when you're running tests on a server, where no one is looking at a GUI, it will save time on performance.

## Headless Testing Tools

### PhantomJS

Development on this tool is suspended, existing features should work, but they are not guaranteed to be supported for long.

This is a headless WebKit, it is scriptable with a JavaScript API. Can be used for website testing, screen capturing, page automation and network monitoring. It can be used for headless testing of web applications.

Supports headless testing with **CasperJS**, a navigation scripting and testing tool for PhantomJS. You can build full navigation scenarios and use high-level functions  in a straightforward interface.

### CasperJS

Comes with a basic testing suite that allows full-featured tests, also allows the capturing of data through web scraping.

It is also no longer maintained.

### Nightmare

High-level browser automation library from Segment. Uses simple methods that mimic user actions "goto" "type" "click". This was originally designed for task automation for sites without APIs but more often used for UI testing and crawling.

```other
npm i nightmare
```

### Mocha

Install Mocha and Nightmare as development dependencies:

```other
npm i --save-dev mocha
npm i --save-dev nightmare
```

Include Mocha as a test script in your package.json

```json
"scripts": { "test" : "mocha" }
```

In the same folder, create `test.js`

```javascript
const Nightmare = require("nightmare");
describe("Load a Page", function () {
  // Recommended: 5s locally, 10s to remote server, 30s from airplane
  this.timeout('30s')
  let nightmare = null;
  beforeEach(() => {
    nightmare = new Nightmare();
  });
  describe("/ (Home Page)", () => {
    it("should load without error", (done) => {
      // your actual testing urls will likely be `http://localhost:port/path`
      nightmare
        .goto("https://www.goal.com/en-ng")
        .end()
        .then(function (result) {
          done();
        })
        .catch(done);
    });
  });
  describe("/live-scores (Live score Page)", () => {
    it("should navigate to /live-scores page and load without error", (done) => {
      // your actual testing urls will likely be `http://localhost:port/path`
      nightmare
        .goto("https://www.goal.com/en-ng")
        .end()
        .then(function (result) {
          done();
        })
        .catch(done);
    });
  });
});
```

### Headless Chrome

This allows us to run the Chrome browser in a headless environment. This will allow you to interact with websites without having a window up on the screen.

```other
chrome --headless --disable-gpu
```

If you want to create a pdf of a particular page

```other
chrome --headless --disable-gpu --print-to-pdf https://www.logrocket.com/
```

If you want to take screenshots

```other
chrome --headless --disable-gpu --screenshot https://www.logrocket.com/
chrome --headless --disable-gpu --screenshot --window-size=1280,1696 https://www.logrocket.com/
```

## Puppeteer

This is a Node.js library developed by the Chrome team. It is a High-Level API to control Headless Chrome. Similar to Phantom and Nightmare but only works with the latest versions of Chrome.

```other
npm i puppeteer
```

```javascript
const puppeteer = require('puppeteer');

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto('https://logrocket.com');
  await page.screenshot({path: 'LR.png'});

  browser.close();
})();
```

Can also create a pdf

```javascript
// puppeteerpdf.js
const puppeteer = require('puppeteer');

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto('http://yomieluwande.me', {waitUntil: 'networkidle'});
  await page.pdf({path: 'YE.pdf', format: 'A4'});
  browser.close();
})();
```

Can also navigate to a page, automate form submissions and keyboard input and display results

```javascript
const puppeteer = require('puppeteer');

(async() => {

    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto('https://google.com', {waitUntil: 'networkidle'});
// Type our query into the search bar
    await page.type('logrocket');

    await page.click('input[type="submit"]');

// Wait for the results to show up
    await page.waitForSelector('h3 a');

// Extract the results from the page
    const links = await page.evaluate(() => {
        const anchors = Array.from(document.querySelectorAll('h3 a'));
        return anchors.map(anchor => anchor.textContent);
    });
    console.log(links.join('\n'));
    browser.close();

})();
```

### Selenium

Another test and automation suite WebDriver.

```other
$ npm install selenium-webdriver chromedriver
```

```javascript
// test.js
const { Builder, By, Key, until } = require('selenium-webdriver');
const chrome = require('selenium-webdriver/chrome');

const chromeOptions = new chrome.Options();
chromeOptions.addArguments('--headless');

async function createDriver() {
  return await new Builder()
    .forBrowser('chrome')
    .setChromeOptions(chromeOptions)
    .build();
}

async function main() {
  const driver = await createDriver();

  try {
    await driver.get('https://www.goal.com/en-ng');
    const title = await driver.getTitle();
    console.log('Page title:', title);
  } finally {
    await driver.quit();
  }
}

main();
```

### Playwright

End to end testing for modern web apps. Supports rendering engnes like Chromium, WebKit, and Firefox.

Headless and headed, locally or CI, cross-platform testing.

```other
$ npm install playwright
```

```javascript
const { chromium } = require('playwright');

async function main() {
  const browser = await chromium.launch({ headless: true });
  const context = await browser.newContext();
  const page = await context.newPage();

  await page.goto('https://www.goal.com/en-ng');
  const title = await page.title();
  console.log('Page title:', title);

  await browser.close();
}
```

## Cypress

End-to-end testing framework, fast, easy and reliable for applications or components that run in browsers.

No servers, drivers or dependencies.

Isolates states of test, clearing browser state before the next test runs.

```other
$ npm install cypress
$ npx cypress open
```

```javascript
// cypress/integration/my_test.spec.js
describe('My Test', () => {
  it('Checks the page title', () => {
    cy.visit('https://www.goal.com/en-ng');
    cy.title().should('eq', 'Football news');
  });
});
```

Configure headless chrome in `cyprus.json`

```json
{
  "baseUrl": "http://localhost:8080",
  "video": false,
  "browser": "chrome",
  "chromeWebSecurity": false
}
```

```other
$ npx cypress run --headless --browser chrome
```

# TDD Feature-Level Tests

## Feature Test Toolbelt

### Chai

- This is a testing library that extends the types of assertions that it is possible to make.
- Chai can be paired with any JAvaSCript testing framework.

### Headless Browsers

- Allowing us to mimic user interaction and evaluate results without rendering a window.

### WebdriverIO

- Methods that allow interaction with user-facing elements

## Feature Tests

- The first feature test that we want to check is the application's *empty state*.
- We want to ensure that when no content is available, that nothing is displayed.

```javascript
describe('Poetry web app', () => {
  describe('user isits root'. () => {
    it('starts as a blank page', () => {
      // using browser.url() we can navigate Phantom to a url, in this case
      browser.url('/');
    })
  })
})
```

## Assert

- To validate that we get expected behavior, use Chai's `assert.equal` method:

```javascript
assert.equal(browser.getText('#poems'), '');
```

- The `.getText()` method comes from WebdriverIO
- Here's a fully fleshed out test:

```javascript
describe('Poetry web app', () => {
  describe('user isits root'. () => {
    it('starts as a blank page', () => {
      browser.url('/');

      assert.equal(browser.getText('#poems'), '');
    })
  })
})
```

## Passing

Once we get the error message, then we can move to the next step in our development process.

If you're using strict TDD, then you only write enough code to make the test pass. The error in the example we received above described that it couldn't find an HTML element with the given id so:

```html
<section id="poems"></section>
```

## Second Feature Test: Setup

After that we want to add another test

```javascript
describe('demo poetry web app', () => { 
    it('saves the user poem and title', () => {
      const title = 'Words Birth Worlds';
      const poem = 'Our words are marvelous weapons with which we could behead the sun';
    });
  });
```

## Second Feature Test: Exercise

We have to then exercise the code, run it through the function or feature that we are testing.

We can use the `.setValue()`  method on `browser` to mimic a user entering a title or poem.

```javascript
describe('demo poetry web app', () => { 
    it('saves the user poem and title', () => {
      // Setup
      const title = 'Words Birth Worlds';
      const poem = 'Our words are marvelous weapons with which we could behead the sun';
     // Exercise
      browser.url('/');
      browser.setValue('input[id=title]', title);
      browser.setValue('textarea[id=poem]', poem);
      browser.click('input[type=submit]');
    });
  });
```

## Second Feature Test: Verify

Now we compare the actual results of the exercise phase to the expected outcome in the "verify" phase.

We can use the `.getText()` on the `browser` and the `.include` method to check if the poem has been submitted

```javascript
const {assert} = require('chai');

describe('User visits root', () => {

  describe('demo poetry web app', () => { 
    it('saves the user poem and title', () => {
      // Setup
      const title = 'Words Birth Worlds';
      const poem = 'Our words are marvelous weapons with which we could behead the sun;
     // Exercise
      browser.url('/');
      browser.setValue('input[id=title]', title);
      browser.setValue('textarea[id=poem]', poem);
      browser.click('input[type=submit]');
      // Verify
      assert.include(browser.getText('#poems'), title);
      assert.include(browser.getText('#poems'), poem);
    });
  });
});
```

## Stuck in the Red

Once we implement the minimal code to mitigate the testing error that we are receiving we reevaluate.

In the above example, if we add an input element with an id=title and a textarea with an id=poem, then we will still have a failing test, but the error will now be an assertion error.

Since we are adding the content with our test, we are stuck. We cannot just add the content to the HTML elements since this is not actually testing our functionality. We must move down a layer at this point. Which will be discussed in the next document.

[Documentation | PhantomJS](https://phantomjs.org/documentation/)

