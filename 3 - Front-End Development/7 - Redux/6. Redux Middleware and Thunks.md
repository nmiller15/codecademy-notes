# Redux Middleware and Thunks

### Middleware in Redux

- Middleware is an extension to the library that you are using that will help handle asynchronous requests. We need this because the Redux store can only really help us handle synchronous code. When you tell it to do something, it will do it immediately.
- Middleware intercepts actions and sits in the middle, between an event handler and the store doing *something*.
- We can write our own middleware, or use libraries available to us.

![Image.png](https://res.craft.do/user/full/b4ae036d-e2e6-fd10-7e5e-f12ec518b2e1/doc/CA578467-1DA9-4F84-BEE2-B119C3D19227/849C0EF4-BC0A-4C4A-8DCC-C1CAEAD57137_2/x6FEnvnpxuivz5RBrfUUaJryvz7E9569JEB6serNobQz/Image.png)

### Write Your Own Middleware

- It’s pretty east to add middleware into a store, we use the `applyMiddleware` function within `createStore()`

```javascript
import { applyMiddleware } from 'redux'
import { middleware1, middleware2, middleware3 } from '../exampleMiddlewares'
// A bunch of other imports

const store = createStore({
  exampleReducer,
  initialState,
  applyMiddleware(
    middleware1,
    middleware2,
    middleware3
  )  
})
```

- All middleware must be a higer-order function that follows this specific framework:

```javascript
const exampleMiddleware = storeAPI => next => action {
  // things and stuff
  return next(action); 
}
```

- The storeAPI, each middleware has access to, these are our store methods `dispatch` and `getState`
- The `next` refers to the next middleware in the pipeline
   - This still needs to be called in the last middleware in the pipline, because in that case `next` is `storeAPI.dispatch` which will continue to pass along the action to the store
- The `action` is the action

### Introduction to Thunks

- A thunk is a higher order function (a function that returns a function, or accepts a function as an argument) that we can use to delay blocks of code from functioning.
- Here’s an example

```javascript
const logStr = (str) => {
  return () => {
    console.log(str)
  }
}
```

- If we call this function ⇒ `logStr('Hello World')` the return statement doesn't execute.
- So, here's what we can do with it

```javascript
const helloWorld = logStr("hello world")

helloWorld() // "hello world"
```

- We can return the function into a new variable - then call it from there later
- The function that we are returning is what we consider to be the *thunk*

### Promise Lifecycle Actions

- Promise Lifecycle Actions are UI-focuesed bits of code that handle every bit of a promise. Starting with a **pending** state, like a loading screen, then a **success** and **error** (or fulfilled and rejected) handler.
- In JS it might look like this

```javascript
import { getData } from './anAPI'

const getDataByParameter = (parameter) => {
  // Execution of request
  // Update the store to change state to "pending"
  try {
    const payload = await getDataByParameter(parameter)
    // Update user data with 'payload'
    // change to a 'fulfilled' state
  } catch {
    // notify store to show data failed to be fetched
  }
}
```

- This pattern is so common that there is a method built in for this.

### `createAsyncThunk()`

```javascript
import { createAsyncThunk } from '@reduxjs/toolkit'
```

- createAsyncThunk
   - Takes 2 arguments:
      - string- action type
      - function - asyncronous callback to be performed
         - This takes an argument and `thunkAPI`
   - Returns:
      - action creator that handles promise lifecycle actions

```javascript
import { createAsyncThunk } from '@reduxjs/toolkit'
import { fetchUser } from './api' 

const fetchUserById = createAsyncThunk(
  'users/fetchUserById'.
  async (arg, thunkAPI) => {
    const response = await fetchUser(arg);
    return response.json();
  }
)
```

### Passing Arguments to Thunks

- The two arguments passed to the async function in `createAsyncThink()` are
   - `arg` - the argument passed to the original function created by `createAsyncThunk`
      - In the above example, if we called `fetchUserById(‘nolan’)` The argument would be `nolan`
      - If you need to pass multiple arguments use an object and destructure them later
      - It doesn’t have to be called `arg` and it is good practice to name it semantically
   - `thunkAPI` which holds methods like `getState` and `dispatch`

### Actions Generated by `createAsyncThunk()`

- `createAsyncThunk()` generates the promise lifecycle action creators using the action type string that you passed to it.
- These are formatted `resourceType/actionType/[pending, fulfilled, rejected]`
- So you can expect their types to be something like:
   - `’users/fetchUserById/pending’`
- And you can access the action createor directly like
   - `fetchUserById.fulfilled`
- The actions are created for you, but its up to you to handle them.

### Using `createSlice()` with Async Action Creators

- So now if we use `createSlice()` and `createAsyncThunk()` together we have a problem. `createSlice()` doesn't know about the actions (and didn't create the action creators) from `createAsyncThunk()`
- We have to tell `createSlice()` about them.
- We can add an optional property, `extraReducers` to our configuration object for `createSlice()`

```javascript
const userSlice = createSlice({
  name: 'users',
  initialState: { users: [] },
  reducers: {
    addUser: (state, action) => {
      state.users.push(action.payload)
    }
  },
  extraReducers: {
    [fetchUserById.pending]: (state, action) => {
      state.isLoading = true;
      state.hasError = false;
    },
    [fetchUserById.fulfilled]: (state, action) => {
      state.users.push(action.payload)
      state.isLoading = false;
      state.hasError = false;
    },
    [fetchUserById.rejected]: (state, action) => {
      state.isLoading = false;
      state.hasError = true;
    }
  }
})
```

- The reason for this syntax is that `fetchUserById.pending` and the others are action creators and to use them directly as a key you have to enclose them in square brackets. This is a *computed property name*.
- In JS if you want to use a variable or expression as a key in an object it must be enclosed this way in square brackets.

