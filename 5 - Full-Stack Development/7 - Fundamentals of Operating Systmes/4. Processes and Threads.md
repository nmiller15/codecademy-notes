# Processes and Threads

## Introduction to Processes

A computer program is a static collection of coded instructions, and a process is an abstraction that represents the program when it’s running.

When a program is executed a process is created.

Processes are the building blocks of an operating system.

Generally, processes operate independetly and do not share data.

## Lifecycle of a Process

Processes have five states that manage their access to limited resources:

`New`: The program has started and is waiting to be added into memory

`Ready`: Process is fully initiated, loaded into memory, and waiting to be picked up by the processor

`Running`: Currently being executed by the processor

`Blocked`: Waiting for a contested resource

`Finished`: Process has been completed

These states allow the CPU to processes many synchornous and asynchronous operations at once, quickly switching between different processes to efficiently and responsively run multiple programs on limitied resources.

## Process Layout and Process Control Block

Each process has for distinct sections:

| Text section | for compiled code                 |
| ------------ | --------------------------------- |
| Data section | initialized variables             |
| Stack        | for local variabiles in functions |
| Heap         | for dynamic memory allocation     |

Each process also has a *process control block* that is required by the operating system for managing the process. This contians:

- A unique process id, PID, and the ID of any parent processes
- The processing state
- Runtime of the process with time limits
- Allowed resources and permissions
- Priority
- Program counter for the address of the instruction being executed
- Address of registers in the CPI that hold intermediate values
- Page, segment tables and other required information for memory management

When on e process launches another, the original enters a parent-child relationship with the newly-launched process that shares much of the data above.

## Introduction to Threads

A process is an abstract data structure representing all of the necessary information to run a program, where a *thread* represents the actual sequence of processor instructions that are actively being executed.

One process can have many threads, and these threads share information with the other threads in the process enabling faster communication and context switching between threads which uses less system resources than context swtiching proceses.

The data that is collected or generated by a thread can then be used in multiple other threads.

## Multithreading

In general, a single CPI core can only execute one thread and one process at a time. But the blocking and context swtiching allow tasks to be completed in nanoseconds, making them almost simultaneous.

There have been hardware advances that allow single CPI cores to execute multiple threads at once through *multithreading*.

There is a trade off of complexity for speed, efficency of utilization and responsiveness. The implementaitons in this environment can be more difficult and create a whole new class of bugs related to multiple threads attempting to modify the same piece of data. There are also deadlocks, where multiple threads all wait for each other and freeze the system.

## Kernel Threads vs User Threads

A kernel thread is a thread that is build into the existing process. The kernel is fully aware tof these threads and directly manages them.

A user thread is functionally identical to a kernal thread, but they are not known or controlled by the kernel and exist solely in userspace. These threads are more efficient than kernel threads because they don’t have to make system calls to interact with the kernel.

User threads are independent of kernel threads but the need to be mapped to existing kernel threads to have the operating system execute them.

- 1:1 Kernel-level threading - best allows for hardware acceleration f=provided by the kernel threads
- N:1 User-level threading - ultra-light threads that can quickly communicate and context switch, they do not benefit from hardware acceleration
- M:N Hybrid threading - sits in the middle of the other two solutions, is more complex and can lead to bugs and mistaken prioritization.

![Image.png](https://res.craft.do/user/full/b4ae036d-e2e6-fd10-7e5e-f12ec518b2e1/doc/8d7e2008-a5ac-4595-8ee8-f2209ae4f501/06C69819-0482-45E2-8AC4-329369989A41_2/EXoxycXbBVSxx5FVrxWVjYhD0Vh7u1T7yN3IgJUGJSoz/Image.png)

